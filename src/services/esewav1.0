// This is v1.0
// In next one i will change the initiation of payment
// we will only return transaction_uuid

import axios from "axios";
import crypto from "crypto";
import {
  AbstractPaymentProcessor,
  isPaymentProcessorError,
  PaymentProcessorContext,
  PaymentProcessorError,
  PaymentProcessorSessionResponse,
  PaymentProviderService,
  PaymentSessionStatus,
} from "@medusajs/medusa";
import { EOL } from "os";
import { Address, Customer } from "@medusajs/medusa";

require('dotenv').config();

class Client {
  private secretKey: string;
  private baseUrl: string;
  private storeUrl: string;

  constructor() {
    this.secretKey = process.env.ESEWA_API_KEY;; // eSewa secret key
    this.baseUrl = process.env.ESEWA_BASE_URL; // eSewa base URL
    this.storeUrl = process.env.STORE_CORS;
  }

  private generateSignature(data: string): string {
    const hmac = crypto.createHmac('sha256', this.secretKey);
    hmac.update(data);
    return hmac.digest('base64');
  }

  private generateRandomId(length) {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return 'dexa1948' + result;
  }

  async initiate(context: PaymentProcessorContext): Promise<any> {
    const { amount, resource_id, paymentSessionData } = context;
    const { 
      product_code, 
      tax_amount: rawTaxAmount, 
      product_service_charge: rawProductServiceCharge, 
      product_delivery_charge: rawProductDeliveryCharge 
    } = paymentSessionData;
    
    const tax_amount = rawTaxAmount as number;
    const product_service_charge = rawProductServiceCharge as number;
    const product_delivery_charge = rawProductDeliveryCharge as number;

    const total_amount = amount + tax_amount + product_service_charge + product_delivery_charge;

    const transaction_uuid = this.generateRandomId(10);

    const success_url = `${this.storeUrl}/order/confirmed?cart_id=${resource_id}`;
    const failure_url = `${this.storeUrl}/order/failed?cart_id=${resource_id}`;

    const signed_field_names = "total_amount,transaction_uuid,product_code";

    const dataToSign = `total_amount=${total_amount},transaction_uuid=${transaction_uuid},product_code=${product_code}`;
    const signature = this.generateSignature(dataToSign);

    const payload = {
      amount,
      tax_amount,
      total_amount,
      transaction_uuid,
      product_code,
      product_service_charge,
      product_delivery_charge,
      success_url,
      failure_url,
      signed_field_names,
      signature,
    };

    return payload;
  }

  async checkPaymentStatus(transaction_uuid: string, total_amount: number): Promise<any> {
    const response = await axios.get(`${this.baseUrl}/api/epay/transaction/status`, {
      params: {
        product_code: "EPAYTEST",
        transaction_uuid,
        total_amount,
      },
    });
    return response.data;
  }

  decodeBase64Response(encodedData: string): any {
    const decodedData = Buffer.from(encodedData, 'base64').toString('utf-8');
    return JSON.parse(decodedData);
  }

  verifySignature(data: any): boolean {
    const { signed_field_names, signature, ...fields } = data;
    const fieldNames = signed_field_names.split(",");

    // Create the string to sign by joining the fields and values in the correct format
    const dataToSign = fieldNames.map((field: string) => `${field}=${fields[field]}`).join(",");
    const generatedSignature = this.generateSignature(dataToSign);

    return generatedSignature === signature;
  }

}

class EsewaPaymentService extends AbstractPaymentProcessor {
  static identifier = "esewa-payment";
  protected paymentProviderService: PaymentProviderService;
  protected client: Client;

  constructor(container, options) {
    super(container);
    this.client = new Client();
    this.paymentProviderService = container.paymentProviderService;
  }

  protected buildError(
    message: string,
    e: PaymentProcessorError | Error
  ): PaymentProcessorError {
    return {
      error: message,
      code: "code" in e ? e.code : "",
      detail: isPaymentProcessorError(e)
        ? `${e.error}${EOL}${e.detail ?? ""}`
        : "detail" in e
          ? e.detail
          : e.message ?? "",
    };
  }

  async capturePayment(
    paymentSessionData: Record<string, unknown>
  ): Promise<Record<string, unknown> | PaymentProcessorError> {
    try {
      const paymentStatus = await this.getPaymentStatus(paymentSessionData);

      if (paymentStatus === PaymentSessionStatus.AUTHORIZED) {
        return {
          status: "captured",
        };
      } else {
        return this.buildError("Payment not complete", new Error(paymentStatus));
      }
    } catch (e) {
      return this.buildError("Failed to capture payment", e);
    }
  }

  async authorizePayment(
    paymentSessionData: Record<string, unknown>,
    context: Record<string, unknown>
  ): Promise<
    PaymentProcessorError |
    {
      status: PaymentSessionStatus;
      data: Record<string, unknown>;
    }
  > {
    try {
      const paymentStatus = await this.getPaymentStatus(paymentSessionData);

      if (paymentStatus === PaymentSessionStatus.AUTHORIZED) {
        return {
          status: PaymentSessionStatus.AUTHORIZED,
          data: {
            transaction_uuid: paymentSessionData.transaction_uuid,
          },
        };
      } else {
        return {
          status: PaymentSessionStatus.REQUIRES_MORE,
          data: {
            transaction_uuid: paymentSessionData.transaction_uuid,
          },
        };
        // return this.buildError("Failed to authorize payment", new Error(statusData.status));
      }
    } catch (e) {
      return this.buildError("Failed to authorize payment", e);
    }
  }

  async cancelPayment(
    paymentSessionData: Record<string, unknown>
  ): Promise<Record<string, unknown> | PaymentProcessorError> {
    return this.buildError("Cannot cancel esewa payment", new Error("Contact Esewa to cancel payment"));
  }

  async initiatePayment(
    context: PaymentProcessorContext
  ): Promise<
    PaymentProcessorError | PaymentProcessorSessionResponse
  > {
    try {
      const payload = await this.client.initiate(context);

      // Return the session data including the form to be used on the storefront
      return {
        session_data: {
          transaction_uuid: payload.transaction_uuid,
          form: payload,
        },
      };
    } catch (e) {
      return this.buildError("Failed to initiate payment", e);
    }
  }

  async deletePayment(
    paymentSessionData: Record<string, unknown>
  ): Promise<Record<string, unknown> | PaymentProcessorError> {
    const transaction_uuid = paymentSessionData.transaction_uuid

    return this.buildError("Cannot delete esewa payment", new Error("Contact Esewa to delete payment"));
  }

  async getPaymentStatus(
    paymentSessionData: Record<string, unknown>
  ): Promise<PaymentSessionStatus> {
    const transaction_uuid = paymentSessionData.transaction_uuid as string;
    const total_amount = paymentSessionData.amount as number;

    try {
      const statusData = await this.client.checkPaymentStatus(transaction_uuid, total_amount);
      const statusMap: { [key: string]: PaymentSessionStatus } = {
        COMPLETE: PaymentSessionStatus.AUTHORIZED,
        PENDING: PaymentSessionStatus.PENDING,
        CANCELED: PaymentSessionStatus.CANCELED,
        AMBIGUOUS: PaymentSessionStatus.PENDING,
        NOT_FOUND: PaymentSessionStatus.CANCELED,
      };
      return statusMap[statusData.status] || PaymentSessionStatus.ERROR;
    } catch (e) {
      return PaymentSessionStatus.PENDING;
    }
  }

  async refundPayment(
    paymentSessionData: Record<string, unknown>,
    refundAmount: number
  ): Promise<Record<string, unknown> | PaymentProcessorError> {
    const transaction_uuid = paymentSessionData.transaction_uuid
    // assuming client is an initialized client
    // communicating with a third-party service.
    // const refundData = this.client.refund(transaction_uuid, refundAmount)

    // return {
    //   transaction_uuid: transaction_uuid,
    //   ...refundData
    // }

    return this.buildError("Cannot refund esewa payment", new Error("Contact Esewa to refund payment"));
  }

  async retrievePayment(
    paymentSessionData: Record<string, unknown>
  ): Promise<Record<string, unknown> | PaymentProcessorError> {
    const transaction_uuid = paymentSessionData.transaction_uuid as string;
    const total_amount = paymentSessionData.amount as number;

    try {
      return await this.client.checkPaymentStatus(transaction_uuid, total_amount);
    } catch (e) {
      return this.buildError("Failed to retrieve payment", e);
    }
  }

  async updatePayment(
    context: PaymentProcessorContext
  ): Promise<
    void |
    PaymentProcessorError |
    PaymentProcessorSessionResponse
  > {
    return;
  }

  async updatePaymentData(
    sessionId: string,
    data: Record<string, unknown>
  ): Promise<
    Record<string, unknown> |
    PaymentProcessorError
  > {
    try {
      const paymentSession = await this.paymentProviderService.retrieveSession(sessionId);

      // Transform the data to match PaymentProcessorContext
      const paymentProcessorContext: PaymentProcessorContext = {
        billing_address: paymentSession.data.billing_address as Address | null,
        email: paymentSession.data.email as string,
        currency_code: paymentSession.data.currency_code as string,
        amount: paymentSession.data.amount as number,
        resource_id: paymentSession.data.resource_id as string,
        customer: paymentSession.data.customer as Customer,
        context: paymentSession.data.context as Record<string, unknown>,
        paymentSessionData: data,
      };

      return {
        transaction_uuid: paymentSession.data.transaction_uuid,
        ...paymentProcessorContext,
      };
    } catch (e) {
      return this.buildError("Failed to update payment data", e);
    }
  }

  // async handleSuccessCallback(query: any): Promise<PaymentProcessorError | { status: string, data: Record<string, unknown> }> {
  //   const encodedData = query.data;

  //   try {
  //     // Decode the base64 encoded response data
  //     const decodedData = this.client.decodeBase64Response(encodedData);

  //     // Verify the signature
  //     if (!this.client.verifySignature(decodedData)) {
  //       return this.buildError("Invalid signature", new Error("Signature verification failed"));
  //     }

  //     const { transaction_uuid, total_amount, status, paymentSessionId } = decodedData;

  //     if (status === "COMPLETE") {
  //       // Update the payment session status to authorized (captured)
  //       const updatedSession = await this.paymentProviderService.updateSession(
  //         {
  //           transaction_uuid: paymentSessionId,
  //           data: {},
  //           provider_id: EsewaPaymentService.identifier,
  //         },
  //         {
  //           status: PaymentSessionStatus.AUTHORIZED,
  //         }
  //       );

  //       return {
  //         status: "success",
  //         data: updatedSession,
  //       };
  //     } else {
  //       return this.buildError("Payment verification failed", new Error(status));
  //     }
  //   } catch (e) {
  //     return this.buildError("Failed to handle success callback", e);
  //   }
  // }
}

export default EsewaPaymentService;
